/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActivityCursor
 */
export interface ActivityCursor {
    /**
     * 
     * @type {number}
     * @memberof ActivityCursor
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityCursor
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ActivityFilter
 */
export interface ActivityFilter {
    /**
     * 
     * @type {ActivityCursor}
     * @memberof ActivityFilter
     */
    'cursor'?: ActivityCursor;
    /**
     * 
     * @type {number}
     * @memberof ActivityFilter
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActivityFilter
     */
    'following_user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActivityFilter
     */
    'primary_user_id'?: number;
}
/**
 * 
 * @export
 * @interface ActivityPage
 */
export interface ActivityPage {
    /**
     * 
     * @type {number}
     * @memberof ActivityPage
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ActivityRead>}
     * @memberof ActivityPage
     */
    'activities': Array<ActivityRead>;
}
/**
 * 
 * @export
 * @interface ActivityRead
 */
export interface ActivityRead {
    /**
     * 
     * @type {number}
     * @memberof ActivityRead
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActivityRead
     */
    'created_at': string;
    /**
     * 
     * @type {AddToCollectionActivityRead}
     * @memberof ActivityRead
     */
    'add_to_collection'?: AddToCollectionActivityRead;
}
/**
 * 
 * @export
 * @interface AddToCollectionActivityRead
 */
export interface AddToCollectionActivityRead {
    /**
     * 
     * @type {UserRead}
     * @memberof AddToCollectionActivityRead
     */
    'user': UserRead;
    /**
     * 
     * @type {CollectionRead}
     * @memberof AddToCollectionActivityRead
     */
    'collection': CollectionRead;
}
/**
 * 
 * @export
 * @interface AuthorRead
 */
export interface AuthorRead {
    /**
     * 
     * @type {string}
     * @memberof AuthorRead
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AuthorRead
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface BodyPatchCollectionBookLinkCollectionBookLinkPatch
 */
export interface BodyPatchCollectionBookLinkCollectionBookLinkPatch {
    /**
     * 
     * @type {CollectionBookLink}
     * @memberof BodyPatchCollectionBookLinkCollectionBookLinkPatch
     */
    'current_link': CollectionBookLink;
    /**
     * 
     * @type {CollectionBookLink}
     * @memberof BodyPatchCollectionBookLinkCollectionBookLinkPatch
     */
    'new_link': CollectionBookLink;
}
/**
 * 
 * @export
 * @interface BookFilter
 */
export interface BookFilter {
    /**
     * 
     * @type {number}
     * @memberof BookFilter
     */
    'user_id': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof BookFilter
     */
    'collection_ids'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof BookFilter
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof BookFilter
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface BookPage
 */
export interface BookPage {
    /**
     * 
     * @type {number}
     * @memberof BookPage
     */
    'total_count': number;
    /**
     * 
     * @type {Array<UserBookRead>}
     * @memberof BookPage
     */
    'books'?: Array<UserBookRead>;
}
/**
 * 
 * @export
 * @interface BookRead
 */
export interface BookRead {
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'publication_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof BookRead
     */
    'pages'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'cover_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'gid'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'isbn13'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'isbn10'?: string;
    /**
     * 
     * @type {number}
     * @memberof BookRead
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CollectionBookLink
 */
export interface CollectionBookLink {
    /**
     * 
     * @type {number}
     * @memberof CollectionBookLink
     */
    'collection_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionBookLink
     */
    'book_id'?: number;
}
/**
 * 
 * @export
 * @interface CollectionPut
 */
export interface CollectionPut {
    /**
     * 
     * @type {string}
     * @memberof CollectionPut
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionPut
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface CollectionRead
 */
export interface CollectionRead {
    /**
     * 
     * @type {string}
     * @memberof CollectionRead
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionRead
     */
    'id': number;
    /**
     * 
     * @type {CollectionType}
     * @memberof CollectionRead
     */
    'type'?: CollectionType;
    /**
     * 
     * @type {number}
     * @memberof CollectionRead
     */
    'count'?: number;
    /**
     * 
     * @type {Array<CollectionUserLinkRead>}
     * @memberof CollectionRead
     */
    'user_links': Array<CollectionUserLinkRead>;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CollectionType = {
    Saved: 'saved',
    Active: 'active',
    Complete: 'complete'
} as const;

export type CollectionType = typeof CollectionType[keyof typeof CollectionType];


/**
 * 
 * @export
 * @interface CollectionUserLinkPut
 */
export interface CollectionUserLinkPut {
    /**
     * 
     * @type {number}
     * @memberof CollectionUserLinkPut
     */
    'collection_id': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionUserLinkPut
     */
    'user_id': number;
    /**
     * 
     * @type {CollectionUserLinkType}
     * @memberof CollectionUserLinkPut
     */
    'type': CollectionUserLinkType;
}


/**
 * 
 * @export
 * @interface CollectionUserLinkRead
 */
export interface CollectionUserLinkRead {
    /**
     * 
     * @type {number}
     * @memberof CollectionUserLinkRead
     */
    'collection_id': number;
    /**
     * 
     * @type {number}
     * @memberof CollectionUserLinkRead
     */
    'user_id': number;
    /**
     * 
     * @type {CollectionUserLinkType}
     * @memberof CollectionUserLinkRead
     */
    'type': CollectionUserLinkType;
    /**
     * 
     * @type {string}
     * @memberof CollectionUserLinkRead
     */
    'created_at': string;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CollectionUserLinkType = {
    Owner: 'owner',
    Collaborator: 'collaborator',
    Follower: 'follower'
} as const;

export type CollectionUserLinkType = typeof CollectionUserLinkType[keyof typeof CollectionUserLinkType];


/**
 * 
 * @export
 * @interface Comparison
 */
export interface Comparison {
    /**
     * 
     * @type {number}
     * @memberof Comparison
     */
    'less_than_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comparison
     */
    'equal_to_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comparison
     */
    'greater_than_id'?: number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Reaction = {
    Positive: 'positive',
    Negative: 'negative',
    Neutral: 'neutral'
} as const;

export type Reaction = typeof Reaction[keyof typeof Reaction];


/**
 * 
 * @export
 * @interface ReviewPut
 */
export interface ReviewPut {
    /**
     * 
     * @type {number}
     * @memberof ReviewPut
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof ReviewPut
     */
    'book_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewPut
     */
    'notes'?: string;
    /**
     * 
     * @type {Reaction}
     * @memberof ReviewPut
     */
    'reaction': Reaction;
    /**
     * 
     * @type {Comparison}
     * @memberof ReviewPut
     */
    'comparison': Comparison;
}


/**
 * 
 * @export
 * @interface ReviewRead
 */
export interface ReviewRead {
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'book_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewRead
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'rating': number;
    /**
     * 
     * @type {Reaction}
     * @memberof ReviewRead
     */
    'reaction': Reaction;
    /**
     * 
     * @type {boolean}
     * @memberof ReviewRead
     */
    'hide_rank': boolean;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'rank': number;
}


/**
 * 
 * @export
 * @interface TagBookLink
 */
export interface TagBookLink {
    /**
     * 
     * @type {string}
     * @memberof TagBookLink
     */
    'tag_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TagBookLink
     */
    'book_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TagBookLink
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface TagValidation
 */
export interface TagValidation {
    /**
     * 
     * @type {boolean}
     * @memberof TagValidation
     */
    'valid': boolean;
    /**
     * 
     * @type {string}
     * @memberof TagValidation
     */
    'warning'?: string;
}
/**
 * 
 * @export
 * @interface UserBookRead
 */
export interface UserBookRead {
    /**
     * 
     * @type {number}
     * @memberof UserBookRead
     */
    'user_id': number;
    /**
     * 
     * @type {BookRead}
     * @memberof UserBookRead
     */
    'book': BookRead;
    /**
     * 
     * @type {ReviewRead}
     * @memberof UserBookRead
     */
    'review'?: ReviewRead;
    /**
     * 
     * @type {Array<CollectionRead>}
     * @memberof UserBookRead
     */
    'collections'?: Array<CollectionRead>;
    /**
     * 
     * @type {Array<AuthorRead>}
     * @memberof UserBookRead
     */
    'authors'?: Array<AuthorRead>;
}
/**
 * 
 * @export
 * @interface UserLinkPut
 */
export interface UserLinkPut {
    /**
     * 
     * @type {number}
     * @memberof UserLinkPut
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserLinkPut
     */
    'child_id'?: number;
    /**
     * 
     * @type {UserLinkType}
     * @memberof UserLinkPut
     */
    'type': UserLinkType;
}


/**
 * 
 * @export
 * @interface UserLinkRead
 */
export interface UserLinkRead {
    /**
     * 
     * @type {number}
     * @memberof UserLinkRead
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserLinkRead
     */
    'child_id'?: number;
    /**
     * 
     * @type {UserLinkType}
     * @memberof UserLinkRead
     */
    'type': UserLinkType;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const UserLinkType = {
    Follow: 'follow',
    Block: 'block'
} as const;

export type UserLinkType = typeof UserLinkType[keyof typeof UserLinkType];


/**
 * 
 * @export
 * @interface UserPage
 */
export interface UserPage {
    /**
     * 
     * @type {number}
     * @memberof UserPage
     */
    'total_count': number;
    /**
     * 
     * @type {Array<UserRead>}
     * @memberof UserPage
     */
    'users'?: Array<UserRead>;
}
/**
 * 
 * @export
 * @interface UserPut
 */
export interface UserPut {
    /**
     * 
     * @type {string}
     * @memberof UserPut
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPut
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPut
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserPut
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRead
     */
    'id': number;
    /**
     * 
     * @type {UserLinkType}
     * @memberof UserRead
     */
    'link'?: UserLinkType;
}


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Activities
         * @param {ActivityFilter} activityFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesActivitiesPost: async (activityFilter: ActivityFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityFilter' is not null or undefined
            assertParamExists('getActivitiesActivitiesPost', 'activityFilter', activityFilter)
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Activities
         * @param {ActivityFilter} activityFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivitiesActivitiesPost(activityFilter: ActivityFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivitiesActivitiesPost(activityFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Activities
         * @param {ActivityFilter} activityFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesActivitiesPost(activityFilter: ActivityFilter, options?: any): AxiosPromise<ActivityPage> {
            return localVarFp.getActivitiesActivitiesPost(activityFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * @summary Get Activities
     * @param {ActivityFilter} activityFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivitiesActivitiesPost(activityFilter: ActivityFilter, options?: AxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivitiesActivitiesPost(activityFilter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BooksApi - axios parameter creator
 * @export
 */
export const BooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookBookBookIdGet: async (bookId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getBookBookBookIdGet', 'bookId', bookId)
            const localVarPath = `/book/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookTagsBookIdGet: async (bookId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getBookTagsBookIdGet', 'bookId', bookId)
            const localVarPath = `/tags/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Following User Books
         * @param {number} bookId 
         * @param {number} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingUserBooksFollowingBooksBookIdParentIdGet: async (bookId: number, parentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getFollowingUserBooksFollowingBooksBookIdParentIdGet', 'bookId', bookId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('getFollowingUserBooksFollowingBooksBookIdParentIdGet', 'parentId', parentId)
            const localVarPath = `/following/books/{book_id}/{parent_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)))
                .replace(`{${"parent_id"}}`, encodeURIComponent(String(parentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Book
         * @param {number} bookId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBookBookBookIdUserIdGet: async (bookId: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getUserBookBookBookIdUserIdGet', 'bookId', bookId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserBookBookBookIdUserIdGet', 'userId', userId)
            const localVarPath = `/book/{book_id}/{user_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Books
         * @param {BookFilter} bookFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBooksBooksPost: async (bookFilter: BookFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookFilter' is not null or undefined
            assertParamExists('getUserBooksBooksPost', 'bookFilter', bookFilter)
            const localVarPath = `/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Books
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBooksBooksSearchQGet: async (q: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchBooksBooksSearchQGet', 'q', q)
            const localVarPath = `/books/search/{q}`
                .replace(`{${"q"}}`, encodeURIComponent(String(q)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BooksApi - functional programming interface
 * @export
 */
export const BooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookBookBookIdGet(bookId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBookRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookBookBookIdGet(bookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookTagsBookIdGet(bookId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagBookLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookTagsBookIdGet(bookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Following User Books
         * @param {number} bookId 
         * @param {number} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId: number, parentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserBookRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId, parentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Book
         * @param {number} bookId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBookBookBookIdUserIdGet(bookId: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBookRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBookBookBookIdUserIdGet(bookId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User Books
         * @param {BookFilter} bookFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBooksBooksPost(bookFilter: BookFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBooksBooksPost(bookFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search Books
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBooksBooksSearchQGet(q: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBooksBooksSearchQGet(q, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BooksApi - factory interface
 * @export
 */
export const BooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookBookBookIdGet(bookId: number, options?: any): AxiosPromise<UserBookRead> {
            return localVarFp.getBookBookBookIdGet(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookTagsBookIdGet(bookId: number, options?: any): AxiosPromise<Array<TagBookLink>> {
            return localVarFp.getBookTagsBookIdGet(bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Following User Books
         * @param {number} bookId 
         * @param {number} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId: number, parentId: number, options?: any): AxiosPromise<Array<UserBookRead>> {
            return localVarFp.getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId, parentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Book
         * @param {number} bookId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBookBookBookIdUserIdGet(bookId: number, userId: number, options?: any): AxiosPromise<UserBookRead> {
            return localVarFp.getUserBookBookBookIdUserIdGet(bookId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Books
         * @param {BookFilter} bookFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBooksBooksPost(bookFilter: BookFilter, options?: any): AxiosPromise<BookPage> {
            return localVarFp.getUserBooksBooksPost(bookFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Books
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBooksBooksSearchQGet(q: string, offset?: number, limit?: number, options?: any): AxiosPromise<BookPage> {
            return localVarFp.searchBooksBooksSearchQGet(q, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BooksApi - object-oriented interface
 * @export
 * @class BooksApi
 * @extends {BaseAPI}
 */
export class BooksApi extends BaseAPI {
    /**
     * 
     * @summary Get Book
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getBookBookBookIdGet(bookId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getBookBookBookIdGet(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Book
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getBookTagsBookIdGet(bookId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getBookTagsBookIdGet(bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Following User Books
     * @param {number} bookId 
     * @param {number} parentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId: number, parentId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getFollowingUserBooksFollowingBooksBookIdParentIdGet(bookId, parentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Book
     * @param {number} bookId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getUserBookBookBookIdUserIdGet(bookId: number, userId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getUserBookBookBookIdUserIdGet(bookId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Books
     * @param {BookFilter} bookFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getUserBooksBooksPost(bookFilter: BookFilter, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getUserBooksBooksPost(bookFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Books
     * @param {string} q 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public searchBooksBooksSearchQGet(q: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).searchBooksBooksSearchQGet(q, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionBookLinkCollectionBookLinkDelete: async (collectionBookLink: CollectionBookLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionBookLink' is not null or undefined
            assertParamExists('deleteCollectionBookLinkCollectionBookLinkDelete', 'collectionBookLink', collectionBookLink)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionBookLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionCollectionCollectionIdDelete: async (collectionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteCollectionCollectionCollectionIdDelete', 'collectionId', collectionId)
            const localVarPath = `/collection/{collection_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete: async (collectionId: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete', 'collectionId', collectionId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete', 'userId', userId)
            const localVarPath = `/collection/user/link/{collection_id}/{user_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionCollectionCollectionIdGet: async (collectionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getCollectionCollectionCollectionIdGet', 'collectionId', collectionId)
            const localVarPath = `/collection/{collection_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet: async (collectionId: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet', 'collectionId', collectionId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet', 'userId', userId)
            const localVarPath = `/collection/user/link/{collection_id}/{user_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionUserLinkType} [userLinkType] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionsGet: async (userId?: number, userLinkType?: CollectionUserLinkType, type?: CollectionType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (userLinkType !== undefined) {
                localVarQueryParameter['user_link_type'] = userLinkType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionBookLinkCollectionBookLinkPatch: async (bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyPatchCollectionBookLinkCollectionBookLinkPatch' is not null or undefined
            assertParamExists('patchCollectionBookLinkCollectionBookLinkPatch', 'bodyPatchCollectionBookLinkCollectionBookLinkPatch', bodyPatchCollectionBookLinkCollectionBookLinkPatch)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyPatchCollectionBookLinkCollectionBookLinkPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionBookLinkCollectionBookLinkPost: async (collectionBookLink: CollectionBookLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionBookLink' is not null or undefined
            assertParamExists('postCollectionBookLinkCollectionBookLinkPost', 'collectionBookLink', collectionBookLink)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionBookLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionCollectionPut: async (collectionPut: CollectionPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionPut' is not null or undefined
            assertParamExists('putCollectionCollectionPut', 'collectionPut', collectionPut)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Collection User Link
         * @param {CollectionUserLinkPut} collectionUserLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionUserLinkCollectionUserLinkPut: async (collectionUserLinkPut: CollectionUserLinkPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionUserLinkPut' is not null or undefined
            assertParamExists('putCollectionUserLinkCollectionUserLinkPut', 'collectionUserLinkPut', collectionUserLinkPut)
            const localVarPath = `/collection/user/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionUserLinkPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionCollectionCollectionIdDelete(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionCollectionCollectionIdGet(collectionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionCollectionCollectionIdGet(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionUserLinkRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionUserLinkType} [userLinkType] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionsCollectionsGet(userId?: number, userLinkType?: CollectionUserLinkType, type?: CollectionType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionsCollectionsGet(userId, userLinkType, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionBookLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionBookLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCollectionCollectionPut(collectionPut: CollectionPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCollectionCollectionPut(collectionPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Collection User Link
         * @param {CollectionUserLinkPut} collectionUserLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut: CollectionUserLinkPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionUserLinkRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionCollectionCollectionIdDelete(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId: number, userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionCollectionCollectionIdGet(collectionId: number, options?: any): AxiosPromise<CollectionRead> {
            return localVarFp.getCollectionCollectionCollectionIdGet(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Collection User Link
         * @param {number} collectionId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId: number, userId: number, options?: any): AxiosPromise<CollectionUserLinkRead> {
            return localVarFp.getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionUserLinkType} [userLinkType] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionsGet(userId?: number, userLinkType?: CollectionUserLinkType, type?: CollectionType, options?: any): AxiosPromise<Array<CollectionRead>> {
            return localVarFp.getCollectionsCollectionsGet(userId, userLinkType, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: any): AxiosPromise<CollectionBookLink> {
            return localVarFp.patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: any): AxiosPromise<CollectionBookLink> {
            return localVarFp.postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionCollectionPut(collectionPut: CollectionPut, options?: any): AxiosPromise<CollectionRead> {
            return localVarFp.putCollectionCollectionPut(collectionPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Collection User Link
         * @param {CollectionUserLinkPut} collectionUserLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut: CollectionUserLinkPut, options?: any): AxiosPromise<CollectionUserLinkRead> {
            return localVarFp.putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Collection Book Link
     * @param {CollectionBookLink} collectionBookLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Collection
     * @param {number} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollectionCollectionCollectionIdDelete(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Collection User Link
     * @param {number} collectionId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId: number, userId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollectionUserLinkCollectionUserLinkCollectionIdUserIdDelete(collectionId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Collection
     * @param {number} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionCollectionCollectionIdGet(collectionId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionCollectionCollectionIdGet(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Collection User Link
     * @param {number} collectionId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId: number, userId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionUserLinkCollectionUserLinkCollectionIdUserIdGet(collectionId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Collections
     * @param {number} [userId] 
     * @param {CollectionUserLinkType} [userLinkType] 
     * @param {CollectionType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionsCollectionsGet(userId?: number, userLinkType?: CollectionUserLinkType, type?: CollectionType, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionsCollectionsGet(userId, userLinkType, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Collection Book Link
     * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Collection Book Link
     * @param {CollectionBookLink} collectionBookLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Collection
     * @param {CollectionPut} collectionPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public putCollectionCollectionPut(collectionPut: CollectionPut, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).putCollectionCollectionPut(collectionPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Collection User Link
     * @param {CollectionUserLinkPut} collectionUserLinkPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut: CollectionUserLinkPut, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).putCollectionUserLinkCollectionUserLinkPut(collectionUserLinkPut, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthHealthGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthHealthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public healthHealthGet(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).healthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewReviewUserIdBookIdDelete: async (userId: number, bookId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteReviewReviewUserIdBookIdDelete', 'userId', userId)
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('deleteReviewReviewUserIdBookIdDelete', 'bookId', bookId)
            const localVarPath = `/review/{user_id}/{book_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsReviewsGet: async (bookId?: number, userId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bookId !== undefined) {
                localVarQueryParameter['book_id'] = bookId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewReviewPut: async (reviewPut: ReviewPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewPut' is not null or undefined
            assertParamExists('putReviewReviewPut', 'reviewPut', reviewPut)
            const localVarPath = `/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReviewReviewUserIdBookIdDelete(userId, bookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsReviewsGet(bookId?: number, userId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReviewRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsReviewsGet(bookId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putReviewReviewPut(reviewPut: ReviewPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putReviewReviewPut(reviewPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReviewReviewUserIdBookIdDelete(userId, bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsReviewsGet(bookId?: number, userId?: number, options?: any): AxiosPromise<Array<ReviewRead>> {
            return localVarFp.getReviewsReviewsGet(bookId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewReviewPut(reviewPut: ReviewPut, options?: any): AxiosPromise<ReviewRead> {
            return localVarFp.putReviewReviewPut(reviewPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Review
     * @param {number} userId 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).deleteReviewReviewUserIdBookIdDelete(userId, bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reviews
     * @param {number} [bookId] 
     * @param {number} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public getReviewsReviewsGet(bookId?: number, userId?: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getReviewsReviewsGet(bookId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Review
     * @param {ReviewPut} reviewPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public putReviewReviewPut(reviewPut: ReviewPut, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).putReviewReviewPut(reviewPut, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserLinkUsersLinkParentUserIdChildUserIdDelete: async (parentUserId: number, childUserId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentUserId' is not null or undefined
            assertParamExists('deleteUserLinkUsersLinkParentUserIdChildUserIdDelete', 'parentUserId', parentUserId)
            // verify required parameter 'childUserId' is not null or undefined
            assertParamExists('deleteUserLinkUsersLinkParentUserIdChildUserIdDelete', 'childUserId', childUserId)
            const localVarPath = `/users/link/{parent_user_id}/{child_user_id}`
                .replace(`{${"parent_user_id"}}`, encodeURIComponent(String(parentUserId)))
                .replace(`{${"child_user_id"}}`, encodeURIComponent(String(childUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUserUserIdDelete: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserUserUserIdDelete', 'userId', userId)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedUsersUsersLinkedGet: async (type: UserLinkType, parentId?: number, childId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getLinkedUsersUsersLinkedGet', 'type', type)
            const localVarPath = `/users/linked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (childId !== undefined) {
                localVarQueryParameter['child_id'] = childId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUserUserIdGet: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserByIdUserUserIdGet', 'userId', userId)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTagUserTagTagGet: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getUserByTagUserTagTagGet', 'tag', tag)
            const localVarPath = `/user/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserCurrentGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserLinkUsersLinkPut: async (userLinkPut: UserLinkPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLinkPut' is not null or undefined
            assertParamExists('putUserLinkUsersLinkPut', 'userLinkPut', userLinkPut)
            const localVarPath = `/users/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLinkPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserUserPut: async (userPut: UserPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPut' is not null or undefined
            assertParamExists('putUserUserPut', 'userPut', userPut)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Users
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersUserSearchQGet: async (q: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchUsersUserSearchQGet', 'q', q)
            const localVarPath = `/user/search/{q}`
                .replace(`{${"q"}}`, encodeURIComponent(String(q)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTagUserValidateTagGet: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('validateTagUserValidateTagGet', 'tag', tag)
            const localVarPath = `/user/validate/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserUserUserIdDelete(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserUserUserIdDelete(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedUsersUsersLinkedGet(type, parentId, childId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIdUserUserIdGet(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIdUserUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByTagUserTagTagGet(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByTagUserTagTagGet(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUserCurrentGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserCurrentGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLinkRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserLinkUsersLinkPut(userLinkPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserUserPut(userPut: UserPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserUserPut(userPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search Users
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersUserSearchQGet(q: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersUserSearchQGet(q, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTagUserValidateTagGet(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTagUserValidateTagGet(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUserUserIdDelete(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserUserUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: any): AxiosPromise<Array<UserRead>> {
            return localVarFp.getLinkedUsersUsersLinkedGet(type, parentId, childId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUserUserIdGet(userId: number, options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserByIdUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTagUserTagTagGet(tag: string, options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserByTagUserTagTagGet(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserCurrentGet(options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserUserCurrentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: any): AxiosPromise<UserLinkRead> {
            return localVarFp.putUserLinkUsersLinkPut(userLinkPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserUserPut(userPut: UserPut, options?: any): AxiosPromise<UserRead> {
            return localVarFp.putUserUserPut(userPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Users
         * @param {string} q 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersUserSearchQGet(q: string, offset?: number, limit?: number, options?: any): AxiosPromise<UserPage> {
            return localVarFp.searchUsersUserSearchQGet(q, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTagUserValidateTagGet(tag: string, options?: any): AxiosPromise<TagValidation> {
            return localVarFp.validateTagUserValidateTagGet(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete User Link
     * @param {number} parentUserId 
     * @param {number} childUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserUserUserIdDelete(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserUserUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Linked Users
     * @param {UserLinkType} type 
     * @param {number} [parentId] 
     * @param {number} [childId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getLinkedUsersUsersLinkedGet(type, parentId, childId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByIdUserUserIdGet(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByIdUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User By Tag
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByTagUserTagTagGet(tag: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByTagUserTagTagGet(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserUserCurrentGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserUserCurrentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put User Link
     * @param {UserLinkPut} userLinkPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUserLinkUsersLinkPut(userLinkPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put User
     * @param {UserPut} userPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUserUserPut(userPut: UserPut, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUserUserPut(userPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Users
     * @param {string} q 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsersUserSearchQGet(q: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsersUserSearchQGet(q, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Tag
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public validateTagUserValidateTagGet(tag: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).validateTagUserValidateTagGet(tag, options).then((request) => request(this.axios, this.basePath));
    }
}



