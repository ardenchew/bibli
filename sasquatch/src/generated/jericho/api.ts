/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthorRead
 */
export interface AuthorRead {
    /**
     * 
     * @type {string}
     * @memberof AuthorRead
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorRead
     */
    'summary'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthorRead
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface BodyPatchCollectionBookLinkCollectionBookLinkPatch
 */
export interface BodyPatchCollectionBookLinkCollectionBookLinkPatch {
    /**
     * 
     * @type {CollectionBookLink}
     * @memberof BodyPatchCollectionBookLinkCollectionBookLinkPatch
     */
    'current_link': CollectionBookLink;
    /**
     * 
     * @type {CollectionBookLink}
     * @memberof BodyPatchCollectionBookLinkCollectionBookLinkPatch
     */
    'new_link': CollectionBookLink;
}
/**
 * 
 * @export
 * @interface BookAuthorLinkBase
 */
export interface BookAuthorLinkBase {
    /**
     * 
     * @type {number}
     * @memberof BookAuthorLinkBase
     */
    'book_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BookAuthorLinkBase
     */
    'author_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookAuthorLinkBase
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface BookRead
 */
export interface BookRead {
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookRead
     */
    'publication_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof BookRead
     */
    'pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof BookRead
     */
    'id': number;
    /**
     * 
     * @type {Array<BookAuthorLinkBase>}
     * @memberof BookRead
     */
    'author_links': Array<BookAuthorLinkBase>;
    /**
     * 
     * @type {Array<TagBase>}
     * @memberof BookRead
     */
    'tags': Array<TagBase>;
}
/**
 * 
 * @export
 * @interface CollectionBookLink
 */
export interface CollectionBookLink {
    /**
     * 
     * @type {number}
     * @memberof CollectionBookLink
     */
    'collection_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionBookLink
     */
    'book_id'?: number;
}
/**
 * 
 * @export
 * @interface CollectionPut
 */
export interface CollectionPut {
    /**
     * 
     * @type {string}
     * @memberof CollectionPut
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionPut
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface CollectionRead
 */
export interface CollectionRead {
    /**
     * 
     * @type {string}
     * @memberof CollectionRead
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionRead
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionRead
     */
    'id': number;
    /**
     * 
     * @type {CollectionType}
     * @memberof CollectionRead
     */
    'type'?: CollectionType;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const CollectionType = {
    Saved: 'saved',
    Active: 'active',
    Complete: 'complete'
} as const;

export type CollectionType = typeof CollectionType[keyof typeof CollectionType];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Reaction = {
    Positive: 'positive',
    Negative: 'negative',
    Neutral: 'neutral'
} as const;

export type Reaction = typeof Reaction[keyof typeof Reaction];


/**
 * 
 * @export
 * @interface ReviewPut
 */
export interface ReviewPut {
    /**
     * 
     * @type {number}
     * @memberof ReviewPut
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReviewPut
     */
    'book_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewPut
     */
    'notes'?: string;
    /**
     * 
     * @type {Reaction}
     * @memberof ReviewPut
     */
    'reaction': Reaction;
}


/**
 * 
 * @export
 * @interface ReviewRead
 */
export interface ReviewRead {
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'book_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewRead
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReviewRead
     */
    'rating': number;
    /**
     * 
     * @type {Reaction}
     * @memberof ReviewRead
     */
    'reaction': Reaction;
    /**
     * 
     * @type {boolean}
     * @memberof ReviewRead
     */
    'hide_rank': boolean;
}


/**
 * 
 * @export
 * @interface TagBase
 */
export interface TagBase {
    /**
     * 
     * @type {string}
     * @memberof TagBase
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TagBase
     */
    'verified': boolean;
    /**
     * 
     * @type {number}
     * @memberof TagBase
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface TagValidation
 */
export interface TagValidation {
    /**
     * 
     * @type {boolean}
     * @memberof TagValidation
     */
    'valid': boolean;
    /**
     * 
     * @type {string}
     * @memberof TagValidation
     */
    'warning'?: string;
}
/**
 * 
 * @export
 * @interface UserLinkPut
 */
export interface UserLinkPut {
    /**
     * 
     * @type {number}
     * @memberof UserLinkPut
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserLinkPut
     */
    'child_id'?: number;
    /**
     * 
     * @type {UserLinkType}
     * @memberof UserLinkPut
     */
    'type': UserLinkType;
}


/**
 * 
 * @export
 * @interface UserLinkRead
 */
export interface UserLinkRead {
    /**
     * 
     * @type {number}
     * @memberof UserLinkRead
     */
    'parent_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserLinkRead
     */
    'child_id'?: number;
    /**
     * 
     * @type {UserLinkType}
     * @memberof UserLinkRead
     */
    'type': UserLinkType;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const UserLinkType = {
    Follow: 'follow',
    Block: 'block'
} as const;

export type UserLinkType = typeof UserLinkType[keyof typeof UserLinkType];


/**
 * 
 * @export
 * @interface UserPut
 */
export interface UserPut {
    /**
     * 
     * @type {string}
     * @memberof UserPut
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPut
     */
    'tag'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserPut
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'tag'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRead
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * BooksApi - axios parameter creator
 * @export
 */
export const BooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Author
         * @param {number} authorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorAuthorAuthorIdGet: async (authorId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorId' is not null or undefined
            assertParamExists('getAuthorAuthorAuthorIdGet', 'authorId', authorId)
            const localVarPath = `/author/{author_id}`
                .replace(`{${"author_id"}}`, encodeURIComponent(String(authorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookBookBookIdGet: async (bookId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('getBookBookBookIdGet', 'bookId', bookId)
            const localVarPath = `/book/{book_id}`
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BooksApi - functional programming interface
 * @export
 */
export const BooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Author
         * @param {number} authorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorAuthorAuthorIdGet(authorId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorAuthorAuthorIdGet(authorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookBookBookIdGet(bookId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookBookBookIdGet(bookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BooksApi - factory interface
 * @export
 */
export const BooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Author
         * @param {number} authorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorAuthorAuthorIdGet(authorId: number, options?: any): AxiosPromise<AuthorRead> {
            return localVarFp.getAuthorAuthorAuthorIdGet(authorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookBookBookIdGet(bookId: number, options?: any): AxiosPromise<BookRead> {
            return localVarFp.getBookBookBookIdGet(bookId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BooksApi - object-oriented interface
 * @export
 * @class BooksApi
 * @extends {BaseAPI}
 */
export class BooksApi extends BaseAPI {
    /**
     * 
     * @summary Get Author
     * @param {number} authorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getAuthorAuthorAuthorIdGet(authorId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getAuthorAuthorAuthorIdGet(authorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Book
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BooksApi
     */
    public getBookBookBookIdGet(bookId: number, options?: AxiosRequestConfig) {
        return BooksApiFp(this.configuration).getBookBookBookIdGet(bookId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionBookLinkCollectionBookLinkDelete: async (collectionBookLink: CollectionBookLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionBookLink' is not null or undefined
            assertParamExists('deleteCollectionBookLinkCollectionBookLinkDelete', 'collectionBookLink', collectionBookLink)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionBookLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionCollectionCollectionIdDelete: async (collectionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('deleteCollectionCollectionCollectionIdDelete', 'collectionId', collectionId)
            const localVarPath = `/collection/{collection_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionCollectionCollectionIdGet: async (collectionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            assertParamExists('getCollectionCollectionCollectionIdGet', 'collectionId', collectionId)
            const localVarPath = `/collection/{collection_id}`
                .replace(`{${"collection_id"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionsGet: async (userId?: number, type?: CollectionType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionBookLinkCollectionBookLinkPatch: async (bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyPatchCollectionBookLinkCollectionBookLinkPatch' is not null or undefined
            assertParamExists('patchCollectionBookLinkCollectionBookLinkPatch', 'bodyPatchCollectionBookLinkCollectionBookLinkPatch', bodyPatchCollectionBookLinkCollectionBookLinkPatch)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyPatchCollectionBookLinkCollectionBookLinkPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionBookLinkCollectionBookLinkPost: async (collectionBookLink: CollectionBookLink, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionBookLink' is not null or undefined
            assertParamExists('postCollectionBookLinkCollectionBookLinkPost', 'collectionBookLink', collectionBookLink)
            const localVarPath = `/collection_book_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionBookLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionCollectionPut: async (collectionPut: CollectionPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionPut' is not null or undefined
            assertParamExists('putCollectionCollectionPut', 'collectionPut', collectionPut)
            const localVarPath = `/collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollectionCollectionCollectionIdDelete(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionCollectionCollectionIdGet(collectionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionCollectionCollectionIdGet(collectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionsCollectionsGet(userId?: number, type?: CollectionType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionsCollectionsGet(userId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionBookLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionBookLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCollectionCollectionPut(collectionPut: CollectionPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCollectionCollectionPut(collectionPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCollectionCollectionCollectionIdDelete(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Collection
         * @param {number} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionCollectionCollectionIdGet(collectionId: number, options?: any): AxiosPromise<CollectionRead> {
            return localVarFp.getCollectionCollectionCollectionIdGet(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Collections
         * @param {number} [userId] 
         * @param {CollectionType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionsGet(userId?: number, type?: CollectionType, options?: any): AxiosPromise<Array<CollectionRead>> {
            return localVarFp.getCollectionsCollectionsGet(userId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Collection Book Link
         * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: any): AxiosPromise<CollectionBookLink> {
            return localVarFp.patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Collection Book Link
         * @param {CollectionBookLink} collectionBookLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: any): AxiosPromise<CollectionBookLink> {
            return localVarFp.postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Collection
         * @param {CollectionPut} collectionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionCollectionPut(collectionPut: CollectionPut, options?: any): AxiosPromise<CollectionRead> {
            return localVarFp.putCollectionCollectionPut(collectionPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Collection Book Link
     * @param {CollectionBookLink} collectionBookLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollectionBookLinkCollectionBookLinkDelete(collectionBookLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Collection
     * @param {number} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionCollectionCollectionIdDelete(collectionId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollectionCollectionCollectionIdDelete(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Collection
     * @param {number} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionCollectionCollectionIdGet(collectionId: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionCollectionCollectionIdGet(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Collections
     * @param {number} [userId] 
     * @param {CollectionType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionsCollectionsGet(userId?: number, type?: CollectionType, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionsCollectionsGet(userId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Collection Book Link
     * @param {BodyPatchCollectionBookLinkCollectionBookLinkPatch} bodyPatchCollectionBookLinkCollectionBookLinkPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch: BodyPatchCollectionBookLinkCollectionBookLinkPatch, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).patchCollectionBookLinkCollectionBookLinkPatch(bodyPatchCollectionBookLinkCollectionBookLinkPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Collection Book Link
     * @param {CollectionBookLink} collectionBookLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public postCollectionBookLinkCollectionBookLinkPost(collectionBookLink: CollectionBookLink, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).postCollectionBookLinkCollectionBookLinkPost(collectionBookLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Collection
     * @param {CollectionPut} collectionPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public putCollectionCollectionPut(collectionPut: CollectionPut, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).putCollectionCollectionPut(collectionPut, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthHealthGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthHealthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthHealthGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public healthHealthGet(options?: AxiosRequestConfig) {
        return InternalApiFp(this.configuration).healthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewReviewUserIdBookIdDelete: async (userId: number, bookId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteReviewReviewUserIdBookIdDelete', 'userId', userId)
            // verify required parameter 'bookId' is not null or undefined
            assertParamExists('deleteReviewReviewUserIdBookIdDelete', 'bookId', bookId)
            const localVarPath = `/review/{user_id}/{book_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"book_id"}}`, encodeURIComponent(String(bookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsReviewsGet: async (bookId?: number, userId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bookId !== undefined) {
                localVarQueryParameter['book_id'] = bookId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {number} [lessThanId] 
         * @param {number} [equalToId] 
         * @param {number} [greaterThanId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewReviewPut: async (reviewPut: ReviewPut, lessThanId?: number, equalToId?: number, greaterThanId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewPut' is not null or undefined
            assertParamExists('putReviewReviewPut', 'reviewPut', reviewPut)
            const localVarPath = `/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lessThanId !== undefined) {
                localVarQueryParameter['less_than_id'] = lessThanId;
            }

            if (equalToId !== undefined) {
                localVarQueryParameter['equal_to_id'] = equalToId;
            }

            if (greaterThanId !== undefined) {
                localVarQueryParameter['greater_than_id'] = greaterThanId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReviewReviewUserIdBookIdDelete(userId, bookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsReviewsGet(bookId?: number, userId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReviewRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsReviewsGet(bookId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {number} [lessThanId] 
         * @param {number} [equalToId] 
         * @param {number} [greaterThanId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putReviewReviewPut(reviewPut: ReviewPut, lessThanId?: number, equalToId?: number, greaterThanId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putReviewReviewPut(reviewPut, lessThanId, equalToId, greaterThanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Review
         * @param {number} userId 
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReviewReviewUserIdBookIdDelete(userId, bookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Reviews
         * @param {number} [bookId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsReviewsGet(bookId?: number, userId?: number, options?: any): AxiosPromise<Array<ReviewRead>> {
            return localVarFp.getReviewsReviewsGet(bookId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Review
         * @param {ReviewPut} reviewPut 
         * @param {number} [lessThanId] 
         * @param {number} [equalToId] 
         * @param {number} [greaterThanId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewReviewPut(reviewPut: ReviewPut, lessThanId?: number, equalToId?: number, greaterThanId?: number, options?: any): AxiosPromise<ReviewRead> {
            return localVarFp.putReviewReviewPut(reviewPut, lessThanId, equalToId, greaterThanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Review
     * @param {number} userId 
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public deleteReviewReviewUserIdBookIdDelete(userId: number, bookId: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).deleteReviewReviewUserIdBookIdDelete(userId, bookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Reviews
     * @param {number} [bookId] 
     * @param {number} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public getReviewsReviewsGet(bookId?: number, userId?: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getReviewsReviewsGet(bookId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Review
     * @param {ReviewPut} reviewPut 
     * @param {number} [lessThanId] 
     * @param {number} [equalToId] 
     * @param {number} [greaterThanId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public putReviewReviewPut(reviewPut: ReviewPut, lessThanId?: number, equalToId?: number, greaterThanId?: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).putReviewReviewPut(reviewPut, lessThanId, equalToId, greaterThanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserLinkUsersLinkParentUserIdChildUserIdDelete: async (parentUserId: number, childUserId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentUserId' is not null or undefined
            assertParamExists('deleteUserLinkUsersLinkParentUserIdChildUserIdDelete', 'parentUserId', parentUserId)
            // verify required parameter 'childUserId' is not null or undefined
            assertParamExists('deleteUserLinkUsersLinkParentUserIdChildUserIdDelete', 'childUserId', childUserId)
            const localVarPath = `/users/link/{parent_user_id}/{child_user_id}`
                .replace(`{${"parent_user_id"}}`, encodeURIComponent(String(parentUserId)))
                .replace(`{${"child_user_id"}}`, encodeURIComponent(String(childUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUserUserIdDelete: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserUserUserIdDelete', 'userId', userId)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedUsersUsersLinkedGet: async (type: UserLinkType, parentId?: number, childId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getLinkedUsersUsersLinkedGet', 'type', type)
            const localVarPath = `/users/linked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (childId !== undefined) {
                localVarQueryParameter['child_id'] = childId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUserUserIdGet: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserByIdUserUserIdGet', 'userId', userId)
            const localVarPath = `/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTagUserTagTagGet: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getUserByTagUserTagTagGet', 'tag', tag)
            const localVarPath = `/user/tag/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserCurrentGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserLinkUsersLinkPut: async (userLinkPut: UserLinkPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLinkPut' is not null or undefined
            assertParamExists('putUserLinkUsersLinkPut', 'userLinkPut', userLinkPut)
            const localVarPath = `/users/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLinkPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserUserPut: async (userPut: UserPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPut' is not null or undefined
            assertParamExists('putUserUserPut', 'userPut', userPut)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTagUserValidateTagGet: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('validateTagUserValidateTagGet', 'tag', tag)
            const localVarPath = `/user/validate/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserUserUserIdDelete(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserUserUserIdDelete(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedUsersUsersLinkedGet(type, parentId, childId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByIdUserUserIdGet(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByIdUserUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByTagUserTagTagGet(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByTagUserTagTagGet(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUserCurrentGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserCurrentGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLinkRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserLinkUsersLinkPut(userLinkPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserUserPut(userPut: UserPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserUserPut(userPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTagUserValidateTagGet(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTagUserValidateTagGet(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete User Link
         * @param {number} parentUserId 
         * @param {number} childUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUserUserIdDelete(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserUserUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Linked Users
         * @param {UserLinkType} type 
         * @param {number} [parentId] 
         * @param {number} [childId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: any): AxiosPromise<Array<UserRead>> {
            return localVarFp.getLinkedUsersUsersLinkedGet(type, parentId, childId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User By Id
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByIdUserUserIdGet(userId: number, options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserByIdUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User By Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByTagUserTagTagGet(tag: string, options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserByTagUserTagTagGet(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUserCurrentGet(options?: any): AxiosPromise<UserRead> {
            return localVarFp.getUserUserCurrentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put User Link
         * @param {UserLinkPut} userLinkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: any): AxiosPromise<UserLinkRead> {
            return localVarFp.putUserLinkUsersLinkPut(userLinkPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put User
         * @param {UserPut} userPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserUserPut(userPut: UserPut, options?: any): AxiosPromise<UserRead> {
            return localVarFp.putUserUserPut(userPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Tag
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTagUserValidateTagGet(tag: string, options?: any): AxiosPromise<TagValidation> {
            return localVarFp.validateTagUserValidateTagGet(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete User Link
     * @param {number} parentUserId 
     * @param {number} childUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId: number, childUserId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserLinkUsersLinkParentUserIdChildUserIdDelete(parentUserId, childUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserUserUserIdDelete(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserUserUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Linked Users
     * @param {UserLinkType} type 
     * @param {number} [parentId] 
     * @param {number} [childId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getLinkedUsersUsersLinkedGet(type: UserLinkType, parentId?: number, childId?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getLinkedUsersUsersLinkedGet(type, parentId, childId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User By Id
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByIdUserUserIdGet(userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByIdUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User By Tag
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByTagUserTagTagGet(tag: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByTagUserTagTagGet(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserUserCurrentGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserUserCurrentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put User Link
     * @param {UserLinkPut} userLinkPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUserLinkUsersLinkPut(userLinkPut: UserLinkPut, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUserLinkUsersLinkPut(userLinkPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put User
     * @param {UserPut} userPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUserUserPut(userPut: UserPut, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUserUserPut(userPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Tag
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public validateTagUserValidateTagGet(tag: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).validateTagUserValidateTagGet(tag, options).then((request) => request(this.axios, this.basePath));
    }
}



